# Linux Performance Analysis in 60,000 Milliseconds

성능 문제가있는 Linux 서버에 로그인합니다 : 처음 1 분 안에 무엇을 확인합니까?

Netflix에는 대규모 EC2 Linux 클라우드와 다양한 성능 분석 도구가 있어 성능을 모니터링하고 조사합니다. 여기에는 클라우드 전반의 모니터링을위한 Atlas와 주문형 인스턴스 분석을위한 Vector가 포함됩니다.
이러한 도구로 대부분의 문제를 해결할 수 있지만 인스턴스에 로그인하여 표준 Linux 성능 도구를 실행해야하는 경우가 있습니다.

## First 60 Seconds: Summary

이 게시물에서 Netflix Performance Engineering 팀은 표준 Linux 도구를 사용하여 명령 줄에서 최적화 된 성능 조사를 처음 60 초 동안 보여줍니다.
60 초 내에 다음의 10 가지 명령을 실행하여 시스템 리소스 사용 및 실행중인 프로세스에 대한 높은 수준의 아이디어를 얻을 수 있습니다.
해석하기 쉽고 자원 활용도가 높은 오류 및 saturation metrics을 찾으십시오.
saturation는 자원이 처리 할 수있는 것보다 많은로드를 가지며 요청 큐의 길이 또는 대기 시간으로 노출 될 수 있습니다.

```
uptime
dmesg | tail
vmstat 1
mpstat -P ALL 1
pidstat 1
iostat -xz 1
free -m
sar -n DEV 1
sar -n TCP,ETCP 1
top
```

이 명령 중 일부는 sysstat 패키지가 설치되어 있어야합니다.
이러한 명령이 제공하는 메트릭을 사용하면 성능 병목 현상을 찾는 방법 인 USE 방법의 일부를 완료하는 데 도움이됩니다. 여기에는 모든 리소스 (CPU, 메모리, 디스크, e.t.c)에 대한 사용률, 채도 및 오류 메트릭 검사가 포함됩니다.
또한 자원을 확인하고 제외 할 때, 주의를 기울여야합니다. 제거 절차에 따라 조사 대상이 좁혀지며 수사를 추적 할 수 있습니다.


다음 절에서는 프로덕션 시스템의 예제를 사용하여 이러한 명령을 요약합니다. 이 도구에 대한 자세한 내용은 설명서 페이지를 참조하십시오.

### 1. uptime

```
$ uptime
23:51:26 up 21:31, 1 user, load average: 30.02, 26.43, 19.02
```

이것은 실행하려는 작업 (프로세스)의 수를 나타내는 로드 평균을 빠르게 볼 수있는 방법입니다. Linux 시스템에서 이러한 숫자에는 CPU에서 실행하려는 프로세스뿐만 아니라 uninterruptible I/O (일반적으로 디스크 I/O)로 차단 된 프로세스가 포함됩니다.
이것은 리소스 로드 (또는 요구)에 대한 높은 수준의 아이디어를 제공하지만 다른 도구 없이는 제대로 이해할 수 없습니다.
Worth a quick look only. (보는 것으로도 가치가 있습니다.)

세 숫자는 1 분, 5 분 및 15 분 상수로 지수 감쇠 이동 평균 합계입니다.
세 숫자는 시간이 지남에 따라 부하가 어떻게 변하는지를 알려줍니다.
예를 들어 문제가있는 서버를 확인하라는 요청을 받았는데 1 분 값이 15 분 값보다 훨씬 낮 으면 너무 늦게 로그인하여 문제를 놓친 것일 수 있습니다.


위의 예에서 부하 평균은 최근의 증가를 나타내며 1 분 값에 대해 30을 치고 15 분 값에 대해서는 19를 나타냅니다.
숫자가 이렇게 큰 것은 뭔가를 의미합니다 : 아마도 CPU 수요 일 것입니다.
이는 3번째과 4번째로 나올 명령인 vmstat 또는 mpstat에서 확인합니다

### 2. dmesg | tail

```
$ dmesg | tail
[1880957.563150] perl invoked oom-killer: gfp_mask=0x280da, order=0, oom_score_adj=0
[...]
[1880957.563400] Out of memory: Kill process 18694 (perl) score 246 or sacrifice child
[1880957.563408] Killed process 18694 (perl) total-vm:1972392kB, anon-rss:1953348kB, file-rss:0kB
[2320864.954447] TCP: Possible SYN flooding on port 7001. Dropping request.  Check SNMP counters.
```
이는 메시지가 있는 경우, 마지막 10개의 시스템 메시지를 봅니다. 성능 문제를 일으킬 수 있는 오류를 찾으세요. 위의 예는 oom-killer 및 요청을 삭제하는 TCP를 포함합니다.

이 단계를 놓치지 마십시오! dmesg는 항상 점검 할 가치가 있습니다.


### 3. vmstat 1
```
$ vmstat 1
procs ---------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
34  0    0 200889792  73708 591828    0    0     0     5    6   10 96  1  3  0  0
32  0    0 200889920  73708 591860    0    0     0   592 13284 4282 98  1  1  0  0
32  0    0 200890112  73708 591860    0    0     0     0 9501 2154 99  1  0  0  0
32  0    0 200889568  73712 591856    0    0     0    48 11900 2459 99  0  0  0  0
32  0    0 200890208  73712 591860    0    0     0     0 15898 4840 98  1  1  0  0
^C
```
가상 메모리 통계의 약자 인 vmstat (8)은 일반적으로 사용 가능한 도구입니다 (수십 년 전에 BSD 용으로 처음 만들어졌습니다).
각 행에 핵심 서버 통계 요약을 출력한다.

vmstat는 인수 1과 함께 실행되어 1 초 요약을 인쇄합니다.
출력의 첫번째 행에는 이전 초의 결과 대신 부팅 후 평균을 보여주는 일부 컬럼이 있습니다. (in this version of vmstat)
지금은 어떤 열이 어떤 것인지 기억하고 기억하고 싶지 않다면 첫 줄을 건너 뛰십시오.

#### Columns to check:
- r : CPU에서 실행 중이거나 차례를 기다리는 프로세스의 수 입니다.
이것은 I / O를 포함하지 않기 때문에 CPU 포화도(saturation)를 결정하기위한 부하 평균보다 우수한 신호를 제공합니다.
 To interpret: CPU 카운트보다 큰 "r"값은 saturation 입니다.

- free : KB 단위의 사용 가능한 메모리, 카운트 할 숫자가 너무 많으면 여유 메모리가 충분합니다. 명령어 7을 포함한 free -m 명령은 사용 가능한 메모리의 상태를 더 잘 설명합니다.

- si, so : Swap-in과 swap-out. 이 값이 0이 아니면 메모리가 부족합니다.

- us, sy, id, wa, st : 이것은 모든 CPU의 평균적인 고장 시간입니다. 사용자 시간, 시스템 시간 (커널), 유휴(idle), 대기 I/O 및 도난당한 시간(stolen time) (다른 게스트 또는 게스트의 자체 격리 된 드라이버 도메인 인 Xen)입니다.

<br>

만약 CPU가 바쁘다면, 사용자 + 시스템 시간을 합침으로써 CPU time breakdown을 확인할 수도 있다. 일정한 수준의 wait I/O는 디스크 병목을 가리킨다. 이것은 보류 중인 디스크 입출력을 기다리는 작업이 차단되어 CPU가 idle 상태인 것을 말한다.

I/O 처리에는 시스템 시간이 필요합니다. 커널이 I/O를 비효율적으로 처리하고 있을지도 모르는 20% 이상의 높은 시스템 시간 평균은 더 흥미로울 수 있습니다.

위의 예에서 CPU 시간은 거의 전체적으로 사용자 수준이며 응용 프로그램 수준 사용을 가리 킵니다. CPU도 평균 90 % 이상 사용됩니다. 이것이 반드시 문제가 되는 것은 아닙니다. 'r' 컬럼을 이용히여 saturation 정도를 확인하세요.


### 4. mpstat -P ALL 1
```
$ mpstat -P ALL 1
Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015  _x86_64_ (32 CPU)

07:38:49 PM  CPU   %usr  %nice   %sys %iowait   %irq  %soft  %steal  %guest  %gnice  %idle
07:38:50 PM  all  98.47   0.00   0.75    0.00   0.00   0.00    0.00    0.00    0.00   0.78
07:38:50 PM    0  96.04   0.00   2.97    0.00   0.00   0.00    0.00    0.00    0.00   0.99
07:38:50 PM    1  97.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   2.00
07:38:50 PM    2  98.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   1.00
07:38:50 PM    3  96.97   0.00   0.00    0.00   0.00   0.00    0.00    0.00    0.00   3.03
[...]
```
이 명령은 불균형을 검사하는 데 사용할 수있는 CPU 당 CPU 시간을 인쇄합니다.
단일 핫 CPU가 단일 스레드 응용 프로그램의 증거가 될 수 있습니다.

### 5. pidstat 1
```
$ pidstat 1
Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    _x86_64_    (32 CPU)

07:41:02 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
07:41:03 PM     0         9    0.00    0.94    0.00    0.94     1  rcuos/0
07:41:03 PM     0      4214    5.66    5.66    0.00   11.32    15  mesos-slave
07:41:03 PM     0      4354    0.94    0.94    0.00    1.89     8  java
07:41:03 PM     0      6521 1596.23    1.89    0.00 1598.11    27  java
07:41:03 PM     0      6564 1571.70    7.55    0.00 1579.25    28  java
07:41:03 PM 60004     60154    0.94    4.72    0.00    5.66     9  pidstat

07:41:03 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
07:41:04 PM     0      4214    6.00    2.00    0.00    8.00    15  mesos-slave
07:41:04 PM     0      6521 1590.00    1.00    0.00 1591.00    27  java
07:41:04 PM     0      6564 1573.00   10.00    0.00 1583.00    28  java
07:41:04 PM   108      6718    1.00    0.00    0.00    1.00     0  snmp-pass
07:41:04 PM 60004     60154    1.00    4.00    0.00    5.00     9  pidstat
^C
```

Pidstat은 프로세스 별 요약과 거의 같지만 화면을 지우지 않고 롤링 요약을 인쇄합니다. 이것은 시간이 지남에 따라 패턴을보고,보고있는 내용 (복사하여 붙여 넣기)을 조사 기록에 기록하는 데 유용 할 수 있습니다.

위 예제에서 두 개의 자바 프로세스가 대부분의 CPU를 소비하고 있음을 알 수 있다. % CPU 컬럼은 모든 CPU에서의 합계이고, 1591%는 자바 프로세스가 거의 16 개의 CPU를 소비하고 있음을 보여줍니다.



### 6. iostat -xz 1

```
$ iostat -xz 1
Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015  _x86_64_ (32 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          73.96    0.00    3.73    0.03    0.06   22.21

Device:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
xvda        0.00     0.23    0.21    0.18     4.52     2.08    34.37     0.00    9.98   13.80    5.42   2.44   0.09
xvdb        0.01     0.00    1.02    8.94   127.97   598.53   145.79     0.00    0.43    1.78    0.28   0.25   0.25
xvdc        0.01     0.00    1.02    8.86   127.79   595.94   146.50     0.00    0.45    1.82    0.30   0.27   0.26
dm-0        0.00     0.00    0.69    2.32    10.47    31.69    28.01     0.01    3.23    0.71    3.98   0.13   0.04
dm-1        0.00     0.00    0.00    0.94     0.01     3.78     8.00     0.33  345.84    0.04  346.81   0.01   0.00
dm-2        0.00     0.00    0.09    0.07     1.35     0.36    22.50     0.00    2.55    0.23    5.62   1.78   0.03
[...]
^C
```

이것은 block device (디스크)를 이해하기에 좋은 도구이다.

- r/s, w/s, rkB/s, wkB/s : 초당 전송된 read, write, read Kbytes, write Kbyte를 나타냅니다.. 이것들을 workload characterization에 사용합니다.. 성능 문제는 과도한 부하가 가해 졌기 때문에 발생할 수 있습니다.

- await : 밀리초 단위의 I/O 평균 시간. 이 시간은 서비스가 대기중인 시간과 서비스되는 시간을 모두 포함하기 때문에 응용 프로그램이 겪는 시간입니다. 예상보다 큰 평균 시간은 장치 포화 또는 장치 문제의 척도가 될 수 있습니다.

- avgqu-sz : 장치에 발행된 평균 요청 수입니다. 1보다 큰 값은 saturation의 증거가 될 수 있습니다. (비록 장치가 일반적으로 병렬로 요청을 처리할 수 있지만, ...)


- %util : 장치 활용 비율. 실제 기기가 작동하는 시간을 초 단위로 보여주는 사용 비율이다. 장치에 따라 다르지만, 일반적으로 60% 이상의 값은 성능 저하를 일으킬 수 있다. 100%에 가까운 값은 saturation을 나타냅니다.


저장 장치가 많은 백엔드 디스크와 마주하는 논리 디스크 장치의 경우 100% 사용률은 일부 I/O가 100% 처리되는 것을 의미 할 수 있지만 백 엔드 디스크는 포화 상태가 아니며, 훨씬 더 많은 작업을 처리 할 수 ​​있습니다.


디스크 입출력의 불량이 꼭 응용 프로그램 문제는 아니라는 것을 명심하십시오. 응용 프로그램이 대기시간을 직접 차단하고 자제하기 위해 많은 기술이 일반적으로 비동기적 I/O를 사용한다. (예 : 읽기의 경우 미리 읽기, 쓰기의 경우 버퍼링).



### 7. free -m

```
$ free -m
             total       used       free     shared    buffers     cached
Mem:        245998      24545     221453         83         59        541
-/+ buffers/cache:      23944     222053
Swap:            0          0          0
```

맨 오른쪽 두 컬럼은 다음을 보여준다
- buffers : 블록 장치 I/O에 사용되는 버퍼 캐시

- cached : 파일 시스템에서 사용하는 페이지 캐시

우리는 단지 높은 디스크 I/O(iostat로 확인)와 성능 저하를 일으킬 수 있는 사이즈가 거의 0인 상황이 아닌지 확인하길 원한다. 위의 예제는 각각 몇 MB로 좋은 상태이다.

"- / + buffers / cache"는 사용 중인 메모리와 사용 가능한 메모리에 대한 혼동을 덜어줍니다. Linux는 캐시를 위해 사용 가능한 메모리를 사용하지만, 애플리케이션이 필요로하는 경우이를 빠르게 회수 할 수 있습니다. 따라서 캐싱 된 메모리는 이 행에서 사용되는 여유 메모리 열에 포함되어야 합니다. 웹사이트 linuxatemyram 에서도 내용을 확인할 수 있습니다.

ZFS는 free -m 열에 의해 적절히 반영되지 않는 자체 파일 시스템 캐시를 가지고 있으므로 일부 서비스 에서처럼 Linux에서 ZFS를 사용하면 혼란을 겪을 수 있습니다. 사용 가능한 메모리가 실제로 ZFS 캐시에서 필요에 따라 사용 가능할 때 시스템의 사용 가능한 메모리가 부족한 것처럼 보일 수 있습니다.



### 8. sar -n DEV 1

```
$ sar -n DEV 1
Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015     _x86_64_    (32 CPU)

12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00
12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00
12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00
12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00
12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
^C
```

이 도구를 사용하여 네트워크 인터페이스 처리량을 확인합니다. 작업 부하의 척도로 rxkB/s and txkB/s를 확인하고, 또한 어떤 limit에 도달했는지를 체크합니다. 위의 예에서 eth0 receive는 22 Mbytes / s에 도달하며 이는 176 Mbits / sec입니다 (1 Gbit / sec 한계 이하라고도 함).


이 버전에는 또한 장치 사용률에 대한 % ifutil(max of both directions for full duplex)이 있습니다. 이는 우리가 Brendan의 nicstat 도구를 사용하여 측정하는 것입니다.

### 9. sar -n TCP,ETCP 1

```
$ sar -n TCP,ETCP 1
Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    _x86_64_    (32 CPU)

12:17:19 AM  active/s passive/s    iseg/s    oseg/s
12:17:20 AM      1.00      0.00  10233.00  18846.00

12:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
12:17:20 AM      0.00      0.00      0.00      0.00      0.00

12:17:20 AM  active/s passive/s    iseg/s    oseg/s
12:17:21 AM      1.00      0.00   8359.00   6039.00

12:17:20 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
12:17:21 AM      0.00      0.00      0.00      0.00      0.00
^C
```



### 10. top

```
$ top
top - 00:15:40 up 21:56,  1 user,  load average: 31.09, 29.87, 29.92
Tasks: 871 total,   1 running, 868 sleeping,   0 stopped,   2 zombie
%Cpu(s): 96.8 us,  0.4 sy,  0.0 ni,  2.7 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:  25190241+total, 24921688 used, 22698073+free,    60448 buffers
KiB Swap:        0 total,        0 used,        0 free.   554208 cached Mem

   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 20248 root      20   0  0.227t 0.012t  18748 S  3090  5.2  29812:58 java
  4213 root      20   0 2722544  64640  44232 S  23.5  0.0 233:35.37 mesos-slave
 66128 titancl+  20   0   24344   2332   1172 R   1.0  0.0   0:00.07 top
  5235 root      20   0 38.227g 547004  49996 S   0.7  0.2   2:02.74 java
  4299 root      20   0 20.015g 2.682g  16836 S   0.3  1.1  33:14.42 java
     1 root      20   0   33620   2920   1496 S   0.0  0.0   0:03.82 init
     2 root      20   0       0      0      0 S   0.0  0.0   0:00.02 kthreadd
     3 root      20   0       0      0      0 S   0.0  0.0   0:05.35 ksoftirqd/0
     5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H
     6 root      20   0       0      0      0 S   0.0  0.0   0:06.94 kworker/u256:0
     8 root      20   0       0      0      0 S   0.0  0.0   2:38.05 rcu_sched
```
